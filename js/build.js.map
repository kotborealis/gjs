{"version":3,"sources":["Graph.js","GAlg.js","CanvasManager.js","Camera.js","Gjs.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"build.js","sourcesContent":["'use strict';\n\nfunction Graph(settings){\n    const self = this;\n\n    let _NODE_ID_GEN = 0;\n    let _EDGE_ID_GEN = 0;\n    settings = settings || {};\n\n    /**\n     * Arrays of nodes and edges\n     * @type {Array}\n     */\n    this.nodesArray=[];\n    this.edgesArray=[];\n\n    /**\n     * Index of nodes and edges\n     * @type {{}}\n     */\n    this.nodesIndex={};\n    this.edgesIndex={};\n\n    /**\n     * Node neighbour nodes and edges\n     */\n    this.nodeNeighbourNodes = {};\n    this.nodeNeighbourEdges = {};\n\n    /**\n     * Add node/nodes to graph\n     * @param {Array|Object} node\n     */\n    this.addNode = function(node){\n        node = Array.isArray(node) ? node : [node];\n        node.map((i)=>__addNode(i));\n    };\n    /**\n     * Add edge/edges to graph\n     * @param {Array|Object} edge\n     */\n    this.addEdge = function(edge){\n        edge = Array.isArray(edge) ? edge : [edge];\n        edge.map((i)=>__addEdge(i));\n    };\n\n    this.createNode = function(x,y){\n        return __addNode({id:\"NODE!!_\"+_NODE_ID_GEN++,x,y});\n    };\n    this.createEdge = function(s,t){\n        return __addEdge({id:\"EDGE!!_\"+_EDGE_ID_GEN++,s,t});\n    };\n\n    var __addNode = function(node){\n        if(!node.id || (typeof node.id!=='string' && typeof node.id!=='number'))\n            throw new Error(\"Invalid node ID\");\n        if(self.nodesIndex[node.id])\n            throw new Error(\"Node already exists\");\n\n        const _node={};\n        _node.label=node.label||\"\";\n        _node.size=node.size||10;\n        _node.id = node.id;\n\n        _node.x = node.x||0;\n        _node.y = node.y||0;\n\n        _node.active = false;\n        _node.highlight = false;\n\n        self.nodesArray.push(_node);\n        self.nodesIndex[_node.id]=_node;\n        self.nodeNeighbourNodes[_node.id]=[];\n        self.nodeNeighbourEdges[_node.id]=[];\n\n        return _node.id;\n    };\n\n    var __addEdge = function(edge){\n        if(!edge.id || (typeof edge.id!=='string' && typeof edge.id!=='number'))\n            throw new Error(\"Invalid edge ID\");\n        if(!edge.t || (typeof edge.t!=='string' && typeof edge.t!=='number'))\n            throw new Error(\"Invalid edge Target node\");\n        if(!edge.s || (typeof edge.s!=='string' && typeof edge.s!=='number'))\n            throw new Error(\"Invalid edge Source node\");\n        if(!self.nodesIndex[edge.s])\n            throw new Error(\"Edge Source node not exists\");\n        if(!self.nodesIndex[edge.t])\n            throw new Error(\"Edge Target node not exists\");\n        if(self.edgesIndex[edge.id])\n            throw new Error(\"Edge already exists\");\n\n        const _edge = {};\n        _edge.id = edge.id;\n        _edge.s = edge.s;\n        _edge.t = edge.t;\n\n        self.edgesArray.push(_edge);\n        self.edgesIndex[_edge.id]=_edge;\n\n        self.nodeNeighbourNodes[_edge.t].push(_edge.s);\n        self.nodeNeighbourEdges[_edge.t].push(_edge.id);\n\n        self.nodeNeighbourNodes[_edge.s].push(_edge.t);\n        self.nodeNeighbourEdges[_edge.s].push(_edge.id);\n\n        return _edge.id;\n    };\n\n    this.setLayout = function(layout,data){\n        for(let i=0;i<self.nodesArray.length;i++){\n            const c = layout(i,self.nodesArray.length,data);\n            self.nodesArray[i].x = c.x;\n            self.nodesArray[i].y = c.y;\n            console.log(c);\n        }\n    };\n}","'use strict';\nconst GAlg={};\nGAlg.g={};\n\nGAlg.BFSTrace=function(s,t){\n    const trace = _BFSTraceWawe(s,t,false);\n    if(!trace)\n        return false;\n    return _BFSTraceReverse(s,t,trace);\n};\n\nvar _BFSTraceWawe = function(s,t,searchCycle){\n    searchCycle=searchCycle||false;\n    const queue=[];\n    const trace={};\n    let found=false;\n    queue.push(s);\n    trace[s]=0;\n    while(queue.length) {\n        const node = queue.shift();\n        if (node === t && Object.keys(trace).length > 1) {\n            found = true;\n        }\n        else {\n            for (let i = 0; i < GAlg.g.nodeNeighbourNodes[node].length; i++) {\n                const id_ = GAlg.g.nodeNeighbourNodes[node][i];\n                if (trace[id_] === null || trace[id_] === undefined) {\n                    trace[id_] = trace[node] + 1;\n                    queue.push(id_);\n                }\n                else if(searchCycle && trace[id_]>=trace[node]){\n                    console.log(id_,node);\n                    found=true;\n                    break;\n                }\n            }\n        }\n        if (found)\n            break;\n    }\n    if(!found)\n        return false;\n    else\n        return trace;\n};\n\nvar _BFSTraceReverse=function(s,t,trace){\n    let c_node=t;\n    const s_trace=[];\n    s_trace.push(t);\n    while(1){\n        if(c_node===s)\n            break;\n        for(let i=0;i<GAlg.g.nodeNeighbourNodes[c_node].length;i++){\n            var id = GAlg.g.nodeNeighbourNodes[c_node][i];\n            if(trace[id]===trace[c_node]-1){\n                s_trace.push(id);\n                c_node=id;\n                break;\n            }\n        }\n    }\n    return s_trace.reverse();\n};\n\nGAlg.Cycle = function(){\n    for(let i=0;i<GAlg.g.nodesArray.length;i++){\n        const nodeId = GAlg.g.nodesArray[i].id;\n        let trace=_BFSTraceWawe(nodeId,nodeId,true);\n        if(trace){\n            return true;\n        }\n    }\n    return false;\n};","'use strict';\n\nfunction CanvasManager(canvas){\n    const self = this;\n\n    if(typeof canvas === 'string')\n        canvas = document.getElementById(canvas);\n    this.canvas = canvas;\n    this.ctx = this.canvas.getContext(\"2d\");\n\n    const _canvas={};\n\n    const _mouse={};\n    _mouse.x=0;\n    _mouse.y=0;\n    _mouse.over=false;\n    _mouse.down=false;\n\n    this.canvas.onmousedown=(e)=>{\n        _mouse.down=true;\n        const {x,y}=canvasCoords(e.clientX,e.clientY);\n        this.onmousedown({x,y});\n    };\n    this.canvas.onmouseup=(e)=>{\n        _mouse.down=false;\n        const {x,y}=canvasCoords(e.clientX,e.clientY);\n        this.onmouseup({x,y});\n    };\n\n    this.canvas.onmouseover=()=>_mouse.over=true;\n    this.canvas.onmouseout=()=>_mouse.over=false;\n\n    this.canvas.onmousemove=(e)=>{\n        if(!_mouse.over)return;\n\n        const {x,y}=canvasCoords(e.clientX,e.clientY);\n        const dx = (x - _mouse.x);\n        const dy = (y - _mouse.y);\n\n        if(_mouse.down)\n            self.ondrag({dx,dy,x,y});\n        else\n            self.onmousemove({x,y});\n\n        _mouse.x=x;\n        _mouse.y=y;\n    };\n\n    this.canvas.onclick=()=>{\n        self.onclick({x:_mouse.x,y:_mouse.y});\n    };\n\n    this.canvas.ondblclick=()=>{\n        self.ondblclick({x:_mouse.x,y:_mouse.y});\n    };\n\n    const canvasCoords = (_x,_y)=>{\n        const x = _x-_canvas.box.left;\n        const y = _y-_canvas.box.top;\n        return {x,y};\n    };\n\n    const _onresize = ()=>{\n        self.canvas.width=window.innerWidth;\n        self.canvas.height=window.innerHeight;\n        _canvas.box=self.canvas.getBoundingClientRect();\n    };\n    window.onresize=_onresize;\n    _onresize();\n\n\n    /**\n     * Events\n     */\n    this.onmousemove=()=>{};\n    this.onclick=()=>{};\n    this.ondblclick=()=>{};\n    this.ondrag=()=>{};\n    this.onmousedown=()=>{};\n    this.onmouseup=()=>{};\n\n    /**\n     * Methods\n     */\n\n    this.clear = (color)=>{\n        self.ctx.fillStyle = color;\n        self.ctx.fillRect(0,0,self.canvas.width,self.canvas.height);\n    };\n}","'use strict';\n\nconst cameraSettings = {\n    viewport:{x:-400,y:-400},\n    nodeColor:{\n        \"\":\"#DD5A5A\",\n        \"hover\":\"#4E9999\",\n        \"highlight\":\"#768DCC\",\n        \"trace\":\"#CE44F4\",\n        \"trace_s\":\"#5021CC\",\n        \"trace_t\":\"#CC1205\"\n    },\n    bgColor:\"#F2F5FC\",\n    edgeColor:{\n        \"\":\"#E87C7C\",\n        \"highlight\":\"#94A4CC\",\n        \"trace\":\"#CE44F4\"\n    },\n    edgeWidth:{\n        \"\":4\n    }\n};\n\nfunction Camera(canvasManager,g,cfg){\n    cfg=cfg||cameraSettings;\n\n    const ctx = canvasManager.ctx;\n    this.viewportOffset={x:0,y:0};\n\n    const redraw = ()=>{\n        startRender();\n        edgeRender();\n        nodeRender();\n        endRender();\n        requestAnimationFrame(redraw);\n    };\n    requestAnimationFrame(redraw);\n\n    const startRender = ()=>{\n        canvasManager.clear(cfg.bgColor);\n        ctx.save();\n        ctx.translate(-viewport().x,-viewport().y);\n    };\n\n    const endRender = ()=>{\n        ctx.restore();\n    };\n\n    const nodeRender = ()=>{\n        ctx.font=\"20px Arial\";\n        g.nodesArray.map((node)=>{\n            ctx.fillStyle=cfg.nodeColor.hasOwnProperty(node.prop)?cfg.nodeColor[node.prop]:cfg.nodeColor[\"\"];\n            ctx.beginPath();\n            ctx.arc(node.x,node.y,node.size,0,2*Math.PI,false);\n            ctx.fill();\n            ctx.closePath();\n            ctx.fillStyle=\"black\";\n            ctx.fillText(node.id,node.x,node.y);\n        });\n    };\n\n    const edgeRender = ()=>{\n        ctx.lineWidth=cfg.edgeWidth[\"\"];\n        g.edgesArray.map((edge)=>{\n            ctx.strokeStyle=cfg.edgeColor.hasOwnProperty(edge.prop)?cfg.edgeColor[edge.prop]:cfg.edgeColor[\"\"];\n            ctx.beginPath();\n            ctx.moveTo(g.nodesIndex[edge.s].x,g.nodesIndex[edge.s].y);\n            ctx.lineTo(g.nodesIndex[edge.t].x,g.nodesIndex[edge.t].y);\n            ctx.stroke();\n            ctx.closePath();\n        });\n    };\n\n    const viewport = ()=>{\n        const x = cfg.viewport.x-this.viewportOffset.x;\n        const y = cfg.viewport.y-this.viewportOffset.y;\n        return {x,y};\n    };\n\n    this.viewportCoords = (x,y)=>{\n        x = x+viewport().x;\n        y = y+viewport().y;\n        return {x,y};\n    };\n}","'use strict';\n\nfunction Gjs(canvas,nodes,edges){\n    var g = new Graph();\n    GAlg.g = g;\n    g.addNode(nodes);\n    g.addEdge(edges);\n    g.setLayout(circleLayout,{r:150});\n    var canvasManager = new CanvasManager(canvas);\n    var camera = new Camera(canvasManager,g);\n\n    let hoverNodeId=null;\n    let highlightNodeId=[];\n    let highlightEdgeId=[];\n    let dragNodeId=null;\n    let edgeSourceNodeId=null;\n    let nodeBFSTrace=[];\n\n    const specialMarked={};\n    specialMarked.nodes={};\n    specialMarked.edges={};\n    specialMarked.nodes.BFSTraceNodeId=[];\n    specialMarked.edges.BFSTraceEdgeId=[];\n\n    this.layout=(layout,data)=>{\n        g.nodesArray.map((node,i)=>{\n            const c = layout(i,g.nodesArray.length,data);\n            node.x=c.x;\n            node.y=c.y;\n        });\n    };\n\n    const addToBFSTrace = (id)=>{\n        if(id===null)return;\n        nodeBFSTrace.push(id);\n        if(nodeBFSTrace.length===2){\n            if(nodeBFSTrace[0]!==nodeBFSTrace[1]) {\n                const trace = GAlg.BFSTrace(nodeBFSTrace[0], nodeBFSTrace[1]);\n                for (let i = 0; i < trace.length; i++) {\n                    const node = trace[i];\n                    setNodeProp(node, \"trace\");\n                    if (i < trace.length - 1) {\n                        const edge = getEdgeIdByST(node, trace[i + 1]);\n                        setEdgeProp(edge, \"trace\");\n                        specialMarked.edges.BFSTraceEdgeId.push(edge);\n                    }\n                }\n                setNodeProp(trace[0], \"trace_s\");\n                setNodeProp(trace[trace.length - 1], \"trace_t\");\n                specialMarked.nodes.BFSTraceNodeId = trace;\n            }\n            nodeBFSTrace=[];\n        }\n        else if(nodeBFSTrace.length>2){\n            nodeBFSTrace=[];\n        }\n    };\n\n    const getEdgeIdByST = (s,t)=>{\n        for(let i=0;i<g.edgesArray.length;i++){\n            const edge=g.edgesArray[i];\n            if((edge.s===s && edge.t===t) || (edge.s===t && edge.t===s))\n                return edge.id;\n        }\n    };\n\n    const setNodeProp = (id,prop)=>{\n        if(id===null)return;\n        let specMarked=false;\n        Object.keys(specialMarked.nodes).map((key)=>{\n            if(specialMarked.nodes[key].includes(id))\n                specMarked=true;\n        });\n        if(specMarked)return;\n        g.nodesIndex[id].prop=prop;\n    };\n    const setEdgeProp = (id,prop)=>{\n        if(id===null)return;\n        let specMarked=false;\n        Object.keys(specialMarked.edges).map((key)=>{\n            if(specialMarked.edges[key].includes(id))\n                specMarked=true;\n        });\n        if(specMarked)return;\n        g.edgesIndex[id].prop=prop;\n    };\n\n    const cleanAllProps = ()=>{\n        Object.keys(specialMarked.nodes).map((key)=>{\n            specialMarked.nodes[key]=[];\n        });\n        Object.keys(specialMarked.edges).map((key)=>{\n            specialMarked.edges[key]=[];\n        });\n        g.edgesArray.map((edge)=>edge.prop=\"\");\n        g.nodesArray.map((node)=>node.prop=\"\");\n    };\n\n    const getNodeIdByCoords = (x,y)=>{\n        let nodeId=null;\n        const _ = camera.viewportCoords(x,y);\n        g.nodesArray.map((node)=>{\n            if(_.x >= node.x-node.size && _.x <= node.x+node.size && _.y >= node.y-node.size && _.y <= node.y+node.size)\n                nodeId=node.id;\n        });\n        return nodeId;\n    };\n\n    const onNodeHover = (id)=>{\n        setNodeProp(hoverNodeId,\"\");\n        setNodeProp(id,\"hover\");\n        hoverNodeId=id;\n\n        highlightNodeId.map((_id)=>setNodeProp(_id));\n        highlightNodeId=[];\n        highlightEdgeId.map((_id)=>setEdgeProp(_id));\n        highlightEdgeId=[];\n\n        if(id===null)return;\n\n        g.nodeNeighbourNodes[id].map((_id)=>{\n            setNodeProp(_id,\"highlight\");\n            highlightNodeId.push(_id);\n        });\n\n        g.nodeNeighbourEdges[id].map((_id)=>{\n            setEdgeProp(_id,\"highlight\");\n            highlightEdgeId.push(_id);\n        });\n    };\n\n    const onNodeDrag = (id,dx,dy)=>{\n        g.nodesIndex[id].x+=dx;\n        g.nodesIndex[id].y+=dy;\n    };\n\n    const onViewportDrag = (dx,dy)=>{\n        camera.viewportOffset.x+=dx;\n        camera.viewportOffset.y+=dy;\n    };\n\n    canvasManager.onmousemove=(e)=>{\n        onNodeHover(getNodeIdByCoords(e.x,e.y));\n    };\n\n    canvasManager.ondrag=(e)=>{\n        if(dragNodeId===null)\n            onViewportDrag(e.dx,e.dy);\n        else\n            onNodeDrag(dragNodeId,e.dx,e.dy);\n    };\n\n    canvasManager.onmousedown=(e)=>{\n        dragNodeId=getNodeIdByCoords(e.x,e.y);\n    };\n\n    canvasManager.onmouseup=()=>{\n        dragNodeId=null;\n    };\n\n    canvasManager.onclick=(e)=>{\n        cleanAllProps();\n        addToBFSTrace(getNodeIdByCoords(e.x,e.y));\n    };\n\n    canvasManager.ondblclick=(e)=>{\n        const id = getNodeIdByCoords(e.x,e.y);\n        if(id===null){\n            const _=camera.viewportCoords(e.x,e.y);\n            const newNode = g.createNode(_.x,_.y);\n            if(edgeSourceNodeId===null)\n                edgeSourceNodeId=newNode;\n            else{\n                g.createEdge(edgeSourceNodeId,newNode);\n                edgeSourceNodeId=null;\n            }\n        }\n        else {\n            if (edgeSourceNodeId === null)\n                edgeSourceNodeId = id;\n            else {\n                g.createEdge(edgeSourceNodeId, id);\n                edgeSourceNodeId = null;\n            }\n        }\n    };\n}\n\nvar circleLayout = function(i,n,data){\n    var x=(data.r*Math.cos(i*2*Math.PI/n))>>0;\n    var y=(data.r*Math.sin(i*2*Math.PI/n))>>0;\n    return {x,y};\n};\nvar gridLayout = function(i,n,data){\n    var x=data.r*(i%data.row);\n    var y=data.r*((i/data.row )<<0);\n    return {x,y};\n};"],"sourceRoot":"/source/"}